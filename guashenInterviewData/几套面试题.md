[TOC]

# 大佬们的面试分享

## EyreFree 头条互娱 Musical.ly 一面

### autoreleasepool 的底层实现有了解么，大概讲一下？用了哪些数据结构呢？

### runloop 底层实现是怎样的呢？timer 在其中是如何处理的？

### 修饰属性有哪些，分别说一下。

## 饶神的头条面试（一面+二面）

### 数组中，有一个数只出现一次，其它的数都出现两次，请找出这个数。

用亦或求解：

```c
#include <iostream>
#include <vector>

using namespace std;

int a[] = {1, 1, 4, 5, 5, 6, 6, 9, 9, 12, 12};

int main() {
    int ans = 0;
    int len = sizeof(a) / sizeof(a[0]);
    for (int i  = 0; i < len; ++ i) {
        ans ^= a[i]; 
    }

    cout << ans << endl;
}
```

### 有一个数只出现一次，其它的数都出现三次，请找出这个数

用 bitmap 思路求解：

```c
#include <iostream>
#include <vector>

using namespace std;

int a[] = {6, 6, 5, 6, 7, 7, 7, 10, 10, 10, 14, 14, 14};
int bitmap[32];

int main() {
    int num[10005];
    memcpy(num, a, sizeof(a));
    int len = sizeof(a) / sizeof(a[0]);
    memset(bitmap, 0, sizeof(bitmap));
    for (int i = 0; i < 32; ++ i) {
        for (int j = 0; j < len; ++ j) {
             int bit = num[j] & 1;
             bitmap[i] += bit;
             num[j] >>= 1;
        }
    }    

    int ans = 0;
    
    for (int i = 0; i < 32; ++ i) {
        if (bitmap[i] % 3 != 0) {
            ans |= (1 << i);
        } 
    }

    cout << ans << endl;
}
```

### autolayout 布局，三个元素如何等宽等距布局，如何在 ipad 上等宽布局，且此时距离不等于 iPhone 上的距离，不能使用 if 判断，

### runtime category 做了什么，添加方法这个事情是在编译器做的还是运行时，运行的哪个阶段，方法覆盖原理，关联对象原理，runtime category 的属性支持 weak 吗，weak 原理。

### 野指针和空指针的区别 距离野指针出现的情况

**空指针**：

1. 没有存储任何内存地址的指针就称为空指针（`NULL` 指针）
2. 空指针即为被赋值为 0 的指针，在没有具体初始化之前，都是 0

**野指针**

野指针一般是指向已经释放的内存的指针。

### 将数组中的 0 移动到所有非 0 元素后面（需要写代码）

## Tamp 头条一面（校招）

### MVC 的一些缺点

1. View 和 Controller 的连接性过于紧密，耦合性还是太大，不利于重用。
2. Controller 所承担的责任太大，往往在复杂逻辑中过重。
3. View 对 Model 的使用率较低，有时候 View 中只展示 Model 的部分数据，但是 View 还会持有一个 Model。


### iOS 中除了 MVC 以外的其他架构方案

1. MVVM
2. VIPER

### 消息队列和线程的关系

1. 开不开线程，取决于执行任务的函数，同步不开，异步开。
2. 开几条线程，取决于队列，串行开一条，并发开多条(异步)
3. 主队列：  专门用来在主线程上调度任务的"队列"，主队列不能在其他线程中调度任务！
4. 如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待
5. 同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。
6. 全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。
7. 也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。

### iOS 中有哪些锁

1. `OSSpinLock` 原子操作自旋锁；
2. 信号量 `dispatch_semaphore_t`。
3. 互斥锁 `pthread_mutex`。
4. 基于 mutex 的 `NSLock`。
5. 条件变量 `NSCondition`。
6. 递归锁 `NSRecursiveLock`。
7. ObjC 中 `@synchronized` 互斥锁。


### 属性的关键字

（答案见 iOS 基础）

### `weak` 如何自动实现 `nil` 赋值？

在 `weak` 变量的初始化阶段有以下源码：

```c
id objc_initWeak(id *location, id newObj) {
	// 查看对象实例是否有效
	// 无效对象直接导致指针释放
    if (!newObj) {
        *location = nil;
        return nil;
    }
    // 这里传递了三个 bool 数值
    // 使用 template 进行常量参数传递是为了优化性能
    return storeWeak<false/*old*/, true/*new*/, true/*crash*/>
        (location, (objc_object*)newObj);
}
```

而在释放阶段，在更新 **SideTable** 的同时会自动将指针指向 `nil`。（nil out 操作）


## Tamp 头条二面（校招）

### `pod install` 和 `pod update` 的区别

**执行 `pod install` 的时候会经历以下的过程：**

1. 读取 `Podfile`

* 读取 `Podfile` 文件：这个文件的语法是使用 Ruby 的 DSL 创造的。其格式仿照了 `Gemfile`。在 Install 过程中第一步就是要弄清楚显式和隐式声明了哪些三方库。在加载 `podspecs` 过程中，CocoaPods 建立了包括版本信息在内的所有三方库列表，每个三方库的 `.podspecs` 温江存储在 `~/.cocoapods` 中。

2. 加载 Source 

* 每个 `.podspec` 文件都包含一个索引，这些索引包括 git 地址和 git tag，以 SHAS 方式存储在 `~/Library/Caches/CocoaPods` 中。这个路径中文件的创建由 *Core Gem* 负责。

3. 生成 `Pods.xcodeproj`

利用 *Core Gem* 加载的组件来对 `Pods.xcodeproj` 工程进行更新，若该文件存在，则创建。

4. 三方库 Install 过程

根据 `target` 添加文件，其中包括 **一个包含编译选项的 `.xcconfig` 文件；一个同时包含编译设置和 CocoaPods 默认配置的私有 `.xcconfig` 文件；一个编译所必须的 `prefix.pch` 文件；另一个编译必须的文件 `dummy.m`**。

5. 写入到磁盘

这步以上的其他功能，都是在内存中进行的，为了重复利用，所以 `Pods.xcodeproj`、`Podfile.lock` 和 `Manifest.lock` 都将被写入磁盘。

**执行 `pod update` 的时候经历的过程**：

而在 `pod update` 过程中，会无视 `Podfile.lock` 的版本限制，重新对依赖进行分析。

### `layoutIfNeeded` 和 `setNeedsLayout` 的区别？

[相关链接](https://blog.csdn.net/susidian/article/details/51068858)

**setNeedsLayout** - 标记位需要重新布局，不立即刷新，在之后 `layoutSubviews` 会被调起，配合 `layoutIfNeeded` 立即更新。

**layoutIfNeed** - 如果有需要刷新的标记，立即调用 `layoutSubviews` 进行布局。

### 自旋锁（OSSpinLock）和互斥锁（pthread_mutex）的区别？

自旋锁和互斥锁有些类似，但是咨询算不会引起调用者睡眠，**如果自旋锁已经被别的执行单元保持，调用者就一直循环再那里看是否该自旋锁的保持者已经释放了锁。**

自旋锁作用是为了解决某项高资源的互斥使用，因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。

从原理上来看，使用互斥锁的时候，线程会从 sleep 加锁状态转变为 running 解锁状态，过程中各有上下文切换，CPU 的抢占以及信号发送等开销。而自旋锁，线程 一直是 running 状态，死循环检测锁的标志位，机制不复杂。

### 如何 Hook 某个对象的方法，而不影响其他对象？

根据 KVO 的方式，对某个对象做类似于 isa-swillzing 的方式，从而生成一个衍生 Class，对这个衍生 Class 再进行 KVO 即可（理论上）。

参考文章 - [五子棋 · 一种基于KVO的页面加载，渲染耗时监控方法](http://satanwoo.github.io/2017/11/27/KVO-Swizzle/) - 这里讲述了如何准确的对  `UIViewController` 的某个子类来监听生命周期方法耗时。使用 KVO 方法来做 method swizzling，其思路与 KVO 本身很像。在业务层面，这种方式可以隔离 super Class 方法的调用，而造成的时间不准确。

### NSMutableArray 的实现原理？

可见自己对于 `CFArray` 的分析，[链接](http://www.desgard.com/CFArray/)。原理为双端队列（deque） + hashmap映射。

## 一秒哥广州头条面试

### iOS 响应链原理是什么？如果不扩大 `UIButton` 范围如何增大点击区域？

`UIResponder` 作为响应者，产生 `UIEvent` 用户交互时间对象。在 `UIView` 中，对于单个 `UIView` 会依次调用 `touchesBegan` -> `touchesMoved` -> `touchesEnded` 这几个方法。从事件响应链传递的层级来看，一般都是 `SubView` -> `SuperView` -> `ViewController` -> `UIWindow` -> `UIApplication` -> `AppDelegate` 这个传递方向，若最终还是没有对象来处理这个事件，则直接抛弃。

`UIApplication` 对象维护者一个响应链堆栈，接收方法是从 `pointInside: withEvnet:` 中处理手势区域，若该方法返回 `true` ，则相应产生的对象压栈。因此扩大 `UIButton` 点击范围，可以 override `pointInside` 来增加 `UIRect` 区域返回 `true` 即可。

### Block 的种类有哪些？Block 原理。

* **_NSConcreteStackBlock**：栈类型，所处地址单元位于高地址。一般情况下声明的 Block 均为该类型，内部引入外部变量但不做赋值操作。
* **_NSConcreteMallocBlock**：堆类型。若需截获 `__block` 变量，改类型 Block 将出现。通过将对象和 Block 复制到堆上，保证了 `__block` 变量的作用域可扩展到 Block 内。这时会使用 `__forwarding` 指针来做关联，示意图如下。
* **_NSConcreteGloalBlock**：全局类型，所处地址单元位于低地址。两种出现时机：1. 在全局变量位置声明；2. Block 中不引入外部变量。

一个 Block 在通过 `clang -rewrite-objc` 重写后，会变成以下数据结构：

```c
struct __block_impl {
	void *isa;
	int Flags;
	int Reserved;
	void *FuncPtr;
};

struct __outside_block_impl_0 {
    struct __block_impl impl;
    struct __outside_block_desc_0* Desc;
    __outside_block_impl_0(void *fp, struct __outside_block_desc_0 *desc, int flags=0) {
        impl.isa = &_NSConcreteGlobalBlock;
        impl.Flags = flags;
        impl.FuncPtr = fp;
        Desc = desc;
    }
};

static struct __outside_block_desc_0 {
	size_t reserved;
	size_t Block_size;
} __outside_block_desc_0_DATA = { 
	0, 
	sizeof(struct __outside_block_impl_0)
};

static void __outside_block_func_0(struct __outside_block_impl_0 *__cself) {
    /* block 的执行体 */
}
```

* **isa**：会指向一种 Block 类对象。在非 GC 的模式下只有三种：`_NSConcreteStackBlock`、`_NSConcreteGlobalBlock`、`_NSConcreteMallocBlock`。
* **Flags**：Block 的负载信息（引用计数和类型信息），按二进制位来存储。
* **Reserved**：保留字段。
* **FuncPtr**：指向 Block 执行体的指针。

### `+ load` 和 `+ initialize` 调用时机

`+ load` 方法的时机是在 Runtime 加载 image、缓存 Class 列表之后开始调用的。其入口方法是 `call_load_methods`。这是会将 SuperClass、SubClass、Category 依次载入到内存中，会有一个全局表来缓存所有的 Class。

`+ initialize` 方法是在 App 首次使用该类的时候由 Runtime 调用，且仅调用一次。我们可以 overrite 这个方法来判断 self 类型，从而做一些对于对象的数据初始化操作。

### 二叉树层序遍历算法

层序遍历其实就是 BFS 广度优先搜索，随便用 C++ 来描述一下：

```c++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
};

void bfs(TreeNode* tRoot) {
    queue<TreeNode *> que;
    que.push(tRoot);
    while (!que.empty()) {
        TreeNode* now = que.front();
        que.pop();
        cout << now -> val << "\t";
        
        if (now -> left) {
            que.push(now -> left); 
        }
        if (now -> right) {
            que.push(now -> right); 
        }
    }
}
```

### `autoreleasepool` 的原理，`autoreleasepool` 使用

`autoreleasepool` 数据结构是由多个 `AutoreleasePoolPage` 组成的一个链式线性表，其数据结构定义如下：

```c
class AutoreleasePoolPage {
    magic_t const magic;        // 用于对当前 AutoreleasePoolPage 完整性校验
    id *next;                   // 指向下一节点
    pthread_t const thread;     // 保存了当前所在页的线程
    AutoreleasePoolPage * const parent; // 父亲节点
    AutoreleasePoolPage *child;         // 孩子节点
    uint32_t const depth;               
    uint32_t hiwat;
};
```

每一个 `AutoreleasePoolPage` 大小均为 `4096` 字节（`0x1000`）。

![](http://p632x9050.bkt.clouddn.com/ch03-1.png)

 每个 `AutoreleasePoolPage` 在内存栈中的图示：
 
 ![](http://p632x9050.bkt.clouddn.com/ch03-2.png)
 
 `POOL_SENTINEL` 是*哨兵对象*，是 `nil` 的宏。在每个 `AutoreleasePage` 被 `objc_autoreleasePoolPush` 的时候，会把一个 `POOL_SENTINEL` 添加到释放池的顶端。这个哨兵就好比是每个池的边界节点，当 `objc_autoreleasePoolPop` 调用时，就会像池中对象发送 `release` 消息，直到访问到第一个 `POOL_SENTINEL` 从而停止 `release` 操作。调度方面除了 `push`、`pop` 常规操作，还有 *满页情况(autoreleaseFullPage)* 和 *无页情况(autoreleaseNoPage)* 的处理，都很常规。
